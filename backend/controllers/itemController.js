const ItemModel = require("../models/itemSchema");
const Item = require("../classes/Item");

// Create a new item
exports.createItem = async (req, res) => {
  try {
    const { title, description, price, brand, category, condition, images, location } = req.body;

    // Create the custom Item object
    const newItem = new Item(
      null, // ID will be generated by MongoDB
      title,
      description,
      price,
      brand,
      category,
      condition,
      images,
      "visible", // Default to visible
      new Date(), // Created date (default is now)
      location
    );

    // Save item to DB (using the Mongoose model)
    const itemDocument = new ItemModel({
      item_id: newItem.itemId,
      title: newItem.title,
      description: newItem.description,
      price: newItem.price,
      brand: newItem.brand,
      category: newItem.category,
      condition: newItem.condition,
      images: newItem.images,
      visibility_status: Item.toBooleanVisibility(newItem.visibilityStatus), // Convert visibility to boolean
      created_at: newItem.createdAt,
      location: newItem.location,
    });

    const savedItem = await itemDocument.save();

    // Return the item (in custom class format)
    res.status(201).json({ message: "Item created successfully", item: new Item(
      savedItem._id,
      savedItem.title,
      savedItem.description,
      savedItem.price,
      savedItem.brand,
      savedItem.category,
      savedItem.condition,
      savedItem.images,
      Item.fromBooleanVisibility(savedItem.visibility_status), // Convert back to string
      savedItem.created_at,
      savedItem.location
    ) });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error creating item" });
  }
};

// Get all items with optional filters (e.g., category, price range)
exports.getItems = async (req, res) => {
  try {
    // Filters can be passed through query params
    const filters = req.query; // e.g., category, price, location
    const items = await ItemModel.find(filters);

    // Return items using the custom Item class
    const result = items.map(item => new Item(
      item._id,
      item.title,
      item.description,
      item.price,
      item.brand,
      item.category,
      item.condition,
      item.images,
      Item.fromBooleanVisibility(item.visibility_status), // Convert visibility back to string
      item.created_at,
      item.location
    ));

    res.status(200).json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error fetching items" });
  }
};

// Get item by ID
exports.getItemById = async (req, res) => {
  try {
    const item = await ItemModel.findById(req.params.itemId);
    if (!item) {
      return res.status(404).json({ message: "Item not found" });
    }

    // Return the item using the custom Item class
    const result = new Item(
      item._id,
      item.title,
      item.description,
      item.price,
      item.brand,
      item.category,
      item.condition,
      item.images,
      Item.fromBooleanVisibility(item.visibility_status), // Convert visibility back to string
      item.created_at,
      item.location
    );

    res.status(200).json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error fetching item" });
  }
};

// Update an item
exports.updateItem = async (req, res) => {
  try {
    const { title, description, price, brand, category, condition, images, visibilityStatus } = req.body;

    const item = await ItemModel.findById(req.params.itemId);
    if (!item) {
      return res.status(404).json({ message: "Item not found" });
    }

    // Ensure the user is updating their own item (authentication check can be added here)
    if (item.seller.toString() !== req.user.id) {
      return res.status(403).json({ message: "You can only update your own items" });
    }

    // Update the item using the new data
    item.title = title || item.title;
    item.description = description || item.description;
    item.price = price || item.price;
    item.brand = brand || item.brand;
    item.category = category || item.category;
    item.condition = condition || item.condition;
    item.images = images || item.images;
    item.visibility_status = Item.toBooleanVisibility(visibilityStatus) || item.visibility_status; // Convert visibility to boolean

    await item.save();

    res.status(200).json({ message: "Item updated successfully", item });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating item" });
  }
};

// Delete an item
exports.deleteItem = async (req, res) => {
  try {
    const item = await ItemModel.findById(req.params.itemId);
    if (!item) {
      return res.status(404).json({ message: "Item not found" });
    }

    // Ensure the user is deleting their own item
   // if (item.seller.toString() !== req.user.id) {
    //  return res.status(403).json({ message: "You can only delete your own items" });
   // }

    await item.remove();
    res.status(200).json({ message: "Item deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error deleting item" });
  }
};
